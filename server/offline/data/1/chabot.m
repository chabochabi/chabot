function chabot (filepath, coin)  filename = strcat(filepath, 'kline_', coin, 'BTC.csv');  klines = dlmread(filename, ',',1,0);  close_prices_total = klines(:,4);    start_idx = 200;  end_idx = 400;  start_idx = 1;  end_idx = length(close_prices_total);    open_prices = klines(:,1)(start_idx:end_idx);  high_prices = klines(:,2)(start_idx:end_idx);  low_prices = klines(:,3)(start_idx:end_idx);  close_prices = klines(:,4)(start_idx:end_idx);  ot = klines(:,5);  #ct = klines(:,6);  volume = klines(:,7)(start_idx:end_idx);  volume_total = klines(:,7);    ## Input checking  #if (nargin < 4 || nargin > 7)  #  print_usage ();  #endif    #close_prices_total = varargin{3};    #high_prices = varargin{1}(start_idx:end_idx);  #low_prices = varargin{2}(start_idx:end_idx);  #close_prices = varargin{3}(start_idx:end_idx);  #open_prices = varargin{4}(start_idx:end_idx);  #volume = varargin{5}(start_idx:end_idx);  #volume_total = varargin{5};    color = "brwk";  ##  if (nargin == 5)##    color = "brwk";##  endif##  if (nargin >= 6)##    color = varargin{6};##  endif##  if (nargin >= 7)##    dates = varargin{7};##  endif##  if (nargin >= 8)##    dateform = varargin{8};##  endif  function retval = is_price_vector (prices)    retval = isnumeric (prices) && isvector (prices) && iscolumn (prices);  endfunction  if ( ! (is_price_vector (high_prices) && is_price_vector (low_prices) && ...          is_price_vector (close_prices) && is_price_vector (open_prices) ) )    error ("candle: prices must be numeric column vector");  endif  num_points = length (high_prices);  if ( ! (num_points == length (low_prices) && ...          num_points == length (close_prices) && ...          num_points == length (open_prices) ) )    error ("candle: price vectors must be of the same size");  endif    num_points = 120;  num_points = length(high_prices);  len = ceil(length(high_prices)/num_points);  cp_rsi = rsindex(close_prices_total);  obv = onbalvol(close_prices_total, volume_total);    #rsi_bursts = zeros(length(cp_rsi),1);  rsi_bursts = [];  good_rsi = [];  bad_rsi = [];  limit = 4;  for n = 1:length(cp_rsi)    if (n>limit)      now_rsi = cp_rsi(n,1);      past_rsi = cp_rsi(n-limit,1);            diff_rsi = (now_rsi-past_rsi)*100/past_rsi;      if ((diff_rsi > 20) && (now_rsi < 50) && (now_rsi > 30))        #rsi_bursts(n,1) = 1;        rsi_bursts = [rsi_bursts n];      endif      if ((past_rsi < 50) && (now_rsi >= 50) && (now_rsi < 70))        good_rsi = [good_rsi n];      endif      if ((past_rsi >= 50) && (now_rsi >= 70))        bad_rsi = [bad_rsi n];      endif    endif  end    for n = 0:len-1        hp = high_prices((n*num_points)+1:(n*num_points)+num_points);    lp = low_prices((n*num_points)+1:(n*num_points)+num_points);    cp = close_prices((n*num_points)+1:(n*num_points)+num_points);    op = open_prices((n*num_points)+1:(n*num_points)+num_points);    vol = volume((n*num_points)+1:(n*num_points)+num_points);    ## Make figure    fig = figure (n+1);    subplot(3,1,1)    washold = ishold;    hold on;    ## Is color a character vector?    if (ischar (color) && size (color, 1) == 1)      if (size (color, 2) == 1)                      # only one color has been user specified        color = [tolower(color) "rwk"];              # so add default colors for down bars, background and wicks      elseif (size (color, 2) == 2)                  # two colors have been user specified        color = [tolower(color) "wk"];               # so add default colors for background and wicks      elseif (size (color, 2) == 3)                  # three colors have been user specified        if (color(3) == "k" || color(3) == "K")      # if user selected background is black         color = [tolower(color) "w"];               # set wicks to default white        else         color = [tolower(color) "k"];               # else default black wicks        endif      elseif (size (color, 2) >= 4)                  # all four colors have been user specified, extra character inputs ignored        color = tolower (color);                     # correct in case user input contains upper case e.g. "BRWK"      endif    else      warning ("candle: COLOR should be a character row vector; ignoring user input");      color = "brwk";    endif                                            # end of nargin >= 5 && ischar (color) && size (color, 1) == 1 if statement    x = 1 : num_points;    x_total = length(close_prices_total)    wicks = hp .- lp;    body = cp .- op;    up_down = sign (body);    scaling = 200 / num_points;    body_width = max(20 * scaling, 1);    wick_width = 1;    doji_size = 10 * max(scaling, 1);    doji_size = 10;    one_price_size = 2 * max(scaling, 1);    ## Background color    plot (hp, color(3), lp, color(3));    fill ( [ min(xlim) max(xlim) max(xlim) min(xlim) ], ...           [ min(ylim) min(ylim) max(ylim) max(ylim) ], color(3) );    function [X, Y] = helper(idx, hi, lo)      high_nan = low_nan = nan (num_points, 1);      high_nan(idx) = hi(idx);      low_nan(idx) = lo(idx);      X = reshape ([ x           ; x          ; nan(1, num_points) ], [], 1);      Y = reshape ([ high_nan(:)'; low_nan(:)'; nan(1, num_points) ], [], 1);    endfunction    ## Plot the wicks    [X, Y] = helper(1 : num_points, hp, lp);    plot (X, Y, color(4), "linewidth", wick_width);    ## FIXME: Use rectangle bar bodies    ## Plot the up bar bodies    [X, Y] = helper (find (up_down == 1), cp, op);    plot (X, Y, color(1), "linewidth", body_width);    ## Plot the down bar bodies    [X, Y] = helper (find (up_down == -1), op, cp);    plot (X, Y, color( 2 ), "linewidth", body_width);    ## Doji bars    doji_ix = find ((hp > lp) .* (cp == op));    if (length (doji_ix) >= 1)      plot (x(doji_ix), cp(doji_ix), ["+" char(color(4))], "markersize", doji_size);    endif    ## Prices all the same    one_price_ix = find ((hp == lp) .* (hp == op) .* (hp == cp));    if (length (one_price_ix) >= 1)      plot (x(one_price_ix), cp(one_price_ix), ["." char(color(4))], "markersize", one_price_size);    endif    ## Revert to previous value of hold    if (! washold)      hold off    endif        subplot(3,1,2);    hold on;    rsi_bursts;    #plot(cp_rsi(n*num_points+1:n*num_points+num_points));    plot(cp_rsi(start_idx:end_idx));    #plot(rsi_bursts(n*num_points+1:n*num_points+num_points));    #plot(x_total(rsi_bursts), cp_rsi(rsi_bursts), ["+" "b"], "markersize", doji_size);    #plot(x_total(good_rsi), cp_rsi(good_rsi), ["+" "g"], "markersize", doji_size);    #plot(x_total(bad_rsi), cp_rsi(bad_rsi), ["+" "r"], "markersize", doji_size);        subplot(3,1,3);    #plot(obv(n*num_points+1:n*num_points+num_points));    #cp_macd = macd(cp');    #cp_macd = macd(close_prices_total');    #plot(cp_macd(start_idx:end_idx)');      end    filename = strcat(filepath, 'trade_', coin, 'BTC.csv');  trades = dlmread(filename, ',',1,0);  trade_times = trades(:,2);#(1:100);  trade_times_mod = trade_times .- mod(trade_times, 60000);  trade_quants = trades(:,5);#(1:100);  trade_maker = trades(:,6);#(1:100);  trade_maker_idx = find(trade_maker == 1);  trade_taker_idx = find(trade_maker == 0);    #length(unique(trade_times_mod))  #length(unique(trade_times_mod(trade_maker_idx)))  #length(unique(trade_times_mod(trade_taker_idx)))  #trade_1m = [trade_times_mod(trade_maker_idx), trade_quants(trade_maker_idx), trade_maker(trade_maker_idx)];  tmp_times = trade_times_mod(trade_maker_idx);  tmp_quants = trade_quants(trade_maker_idx);  #x = [];  makers = [];  ctr = 0;  sum = 0;  i_time = 0;  for i=1:length(tmp_quants)    i_time = tmp_times(i) - mod(tmp_times(i), 60000);        if (i>1)      last_time = tmp_times(i-1) - mod(tmp_times(i-1), 60000);            if (i_time - last_time > 60000)        empty_periods = (i_time - last_time)/60000;        for j=1:empty_periods-1          makers = [makers; 0];          #x = [x; last_time+(j-1)*60000];        end        sum = 0;      endif    endif        if (i == 1)      sum = tmp_quants(i);    elseif (i_time == (tmp_times(i-1) - mod(tmp_times(i-1), 60000)))      sum += tmp_quants(i);    else      ctr += 1;      #x = [x; i_time-60000];      #x = [x; ctr];      makers = [makers; sum];      sum = tmp_quants(i);    endif  end  #x = [x; i_time]  #x = [x; ctr+1];  #makers = [makers; sum];  length(makers);  tmp_times = trade_times_mod(trade_taker_idx);  tmp_quants = trade_quants(trade_taker_idx);  #x = [];  takers = [];  ctr = 0;  sum = 0;  i_time = 0;  for i=1:length(tmp_quants)    i_time = tmp_times(i) - mod(tmp_times(i), 60000);        if (i>1)      last_time = tmp_times(i-1) - mod(tmp_times(i-1), 60000);            if (i_time - last_time > 60000)        empty_periods = (i_time - last_time)/60000;        for j=1:empty_periods-1          takers = [takers; 0];          #x = [x; last_time+(j-1)*60000];        end        sum = 0;      endif    endif        if (i == 1)      sum = -tmp_quants(i);    elseif (i_time == (tmp_times(i-1) - mod(tmp_times(i-1), 60000)))      sum -= tmp_quants(i);    else      ctr += 1;      #x = [x; i_time-60000];      #x = [x; ctr];      takers = [takers; sum];      sum = tmp_quants(i);    endif  end  #x = [x; i_time];  #x = [x; ctr+1];  takers = [takers; sum];  #plot(makers(start_idx:end_idx));  plot(makers);  hold on;  #plot(takers(start_idx:end_idx));  plot(takers);    ## No date argument##    if (nargin < 7)##      return##    endif##    if (! ismatrix (dates))##      warning ("candle: DATES must be a matrix; ignoring DATES");##      return##    endif##    if (! (isnumeric (dates) || ischar (dates)))##      warning ("candle: DATES must be of numeric or character type");##      return##    endif##    if (size (dates, 1) != num_points)##      warning ("candle: DATES and price vectors must be of the same length; ignoring DATES");##      return##    endif##    if (nargin < 8 && isnumeric (dates))##      warning ("candle: if DATES is a serial date number (see datenum) or a datevec matrix (see datevec), DATEFORM is required; ignoring DATES");##      return##    endif##    if (nargin >= 8)##      if (ischar (dates))##        warning ("candle: DATES is of character type but DATEFORM is also specified; ignoring DATES");##        return##      endif##      if (isnumeric (dateform) && (dateform < 0 || dateform > 31))##        warning ("candle: DATEFORM integer code number is out of bounds (See datestr); ignoring DATES");##        return##      elseif (isnumeric (dateform) && rem (dateform, 1) > 0)##        warning ("candle: DATEFORM code number should be an integer 0 - 31 (See datestr); ignoring DATES");##        return##      endif##      if (size (dates, 2) == 1)##        is_monotonically_increasing = sum (dates == cummax (dates)) / size (dates, 1);##        if (is_monotonically_increasing != 1)##          warning ("candle: DATES does not appear to be a serial date number column as it is not monotonically increasing; ignoring DATES");##          return##        endif##      endif##    endif####    if (nargin == 7)##      ticks = cellstr (dates);##    else##      ticks = datestr (dates, dateform);##      ticks = mat2cell (ticks, ones (size (ticks, 1), 1), size (ticks, 2));##    endif####    ## FIXME: choose the number of ticks in a smarter way##    num_ticks = 5;##    xx = 1 : floor(num_points / num_ticks) : num_points;####    h = gca ();##    set (h, "xtick", xx);##    set (h, ["x" "ticklabel"], ticks(xx));endfunction